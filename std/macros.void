export
	macro pub()
		define body expand-macros(&body)
		quote export &body

pub macro `()
	quote quote $@&body

pub macro ':'()
	define expr0 &body.extract(0)
	define expr1 &body.extract(1)
	` labeled-expr $expr0 $expr1

pub macro let()
	define equals-expr (extract &body 0)
	`(
		define
		$(extract equals-expr 1)
		$(extract equals-expr 2)
	)

pub macro var()
	define equals-expr (extract &body 0)
	`(
		define-mut
		$(extract equals-expr 1)
		$(extract equals-expr 2)
	)

pub macro global()
	let mutability = extract &body 0
	let equals-expr = extract &body 1
	let function =
		if mutability == "let" then:
			` define-global
		else:
			` define-mut-global
	`(
		$@function
		$(extract equals-expr 1)
		$(extract (extract equals-expr 2) 1)
	)

pub macro ';'()
	let func = &body.extract(0)
	let body = &body.extract(1)
	let args =
		if body.extract(0) == "block" then:
			body.slice(1)
		else:
			body
	if is-list(func) then:
		func.concat(args)
	else:
		concat(`($func) args)

pub macro lambda()
	let parameters = &body.extract(0)
	let body = &body.extract(1)
	` lambda-expr $parameters $body

pub macro '=>'(&body)
	` lambda $@&body

// Extracts typed parameters from a list where index 0 is fn name, and offset-index+ are labeled-expr
macro-let extract-parameters = (definitions) =>
	`(parameters).concat definitions.slice(1)

pub macro fn()
	let definitions = extract(&body 0)
	let identifier = extract(definitions 0)
	let params = extract-parameters(definitions)

	let type-arrow-index =
		if (extract(&body 1) == "->") then:
			1
		else:
			if (extract(&body 2) == "->") then: 2 else: -1

	let return-type =
		`(
			return-type
			$@(if(type-arrow-index > -1
				then: &body.slice(type-arrow-index + 1 type-arrow-index + 2)
				else: `()))
		)

	let expressions =
		if (type-arrow-index > -1) then:
			&body.slice(type-arrow-index + 2)
		else: &body.slice(1)

	`(
		define-function
		$identifier
		$params
		$return-type
		$(concat #["block"] expressions)
	)

pub macro def-wasm-operator(op wasm-fn arg-type return-type)
	` fn $op(left:$arg-type right:$arg-type) -> $return-type
		binaryen-mod ($arg-type $wasm-fn $return-type) (left right)

// extern $fn-id(namespace params*)
// extern max("Math" x:i32 y:i32)
pub macro extern-fn()
	let namespace = &body.extract(0)
	let definitions = &body.extract(1)
	let identifier = definitions.extract(0)
	let parameters = extract-parameters(definitions)

	let type-arrow-index = if (extract(&body 1) == "->") then:
		1
	else:
		if (extract(&body 2) == "->") then: 2 else: -1

	let return-type =
		` return-type
			$ if (type-arrow-index > -1) then:
				extract(&body type-arrow-index + 1)
			else: `()

	`(
		define-extern-function
		$identifier
		namespace $namespace
		$parameters
		$return-type
	)

pub macro match()
	let value-expr = &body.extract(0)
	let cases = &body.slice(1)
	let expand-cases = (cases index) =>
		let case = cases.extract(index)
		if is-list(case) and not(index + 1 >= cases.length) then:
			` if $(extract case 0) == match-value
				$(extract case 1)
				$(&lambda cases (index + 1))
		else: case

	let conditions = expand-cases(cases 0)
	` block
		let match-value = $value-expr
		$conditions
