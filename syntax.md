# Dream Language Syntax Overview

## Keywords

- if
- else
- elif
- guard
- while
- loop
- for
- in
- def
- let
- var
- struct
- impl
- import
- public
- private
- move
- moveonly
- yeild
- async
- await
- mut
- type
- case
- switch
- where
- static
- enum

## Operators

Arithmetic
- `-` Subtract (Or negate)
- `+` Add
- `*` Multiply
- `/` Divide
- `%` Remainder
- `^` Exponent

Asignment
- `=` Assign to
- `-=` Assign to something subtracted by itself
- `+=` Assign to something added to itself
- `*=` Assign to something multiplied by itself
- `/=` Assign to something divided by itself

Comparison
- `==` Equal to
- `>=` Greater than or equal to
- `<=` Less than or equal to
- `!=` Not equal to
- `>` Greater than
- `<` Less than

Logical
- `!` Not
- `&&` And
- `||` Or

Bitwise
- `~` Not
- `&` And
- `|` Or
- `^|` XOr
- `<<` Left shift
- `>>` Right shift

Other
- `??` Nil-Coalescing Operator
- `...` Range
- `>..` Another range
- `..<` Another range again
- `&+` Overflow add
- `&-` Overflow subtract
- `&*` Overflow multiply

## Examples

```rust
// Single Line Comment

/*
Block Comment
*/

/**************************
Expressions
**************************/

1 + 1
3 * (4 + 1)
2 + 3 * 2

/**************************
Value Declarations
**************************/

// Fixed
let x = 3

// Variable
var y = 2

// Fixed with type annotation
let z: Int = 4

/**************************
Blocks
**************************/

{
    let x = 3 + 4
    x * 2
}

let five = {
    let y = 1 * 2
    y + 3
}

/**************************
If Expressions
**************************/

if 2 == 3 {
    print("Two equals 3")
}

let four = if 1 == 3 { 1 } elif 1 == 1 { 4 } else { 2 }

/**************************
Loops
**************************/

var num = 1
while num < 11 {
    num += 1
}

// Loop infinitely until a break or return statement is encountered
var num2 = 1
loop {
    num2 += 1
    if num2 > 5 { break }
}

// Iterate over something that implements the iterable protocol
for item in list {
    print(item)
}

/**************************
Functions
**************************/

let sq = (x: Int) => x * 2
let mul = (x: Int, y: Int) => x * 2
let doStuff = { () -> Void =>
    print("Hello")
    print("I am a function that does stuff")
    print("I have many lines")
}

// Function calling
sq(3)
mul(2, 4)
doStuff()

/**************************
Tuples
**************************/

let a = (1, 2, 3)
let b: (Int, Int) = (1, 2)
let singleton: (Int) = (1,) // Comma is needed to avoid ambiguity with expression grouping

// Labled tuples
type Point = (x: Int, y: Int, z: Int); // Semi-colon optional
let p1: Point = (x: 1, y: 2, z: 3)

// Shorthand syntax
let x, y, z = 1, 2, 3
let p2 = (:x, :y, :z)

/**************************
Methods
**************************/

def add(a: Int, b: Int) -> Int { a + b }
def add(x: Int, y: Int) -> Int = x + y
def add(_x: Int, _y: Int) -> Int = {
    print("The leading underscores mean the parameter does not need to be labled when called")
    x + y
}

def mul(a x: Int, b y: Int) -> Int {
    print("The call label is different then the parameter label")
    x * y
}

// Method calling
add(a: 1, b: 2)
add(x: 1, y: 2)
add(1, 2)
mul(a: 1, b: 2)

/**************************
Structs
**************************/

struct Point {
    var x, y, z: Int
}

// Like in swift, structs have autogenerated memberwize initializers
let coords = Point(x: 1, y: 2, z: 3)

/**************************
Struct Methods
**************************/

struct Point {
    var x, y, z: Int

    // Note: Members of a struct can be accessed by their name or with self. (Needed only if there is a name conflict)
    def toTuple() -> (Int, Int, Int) = (x, y, z)

    // The mut keyword is needed if the method needs to modify one of it's members
    mut shift(x: Int) -> Void = self.x += x
}

/**************************
Traits
**************************/

trait Coords {
    var x, y, z: Int // Must have vars x, y, and z that are ints

    def offs(x: Int, y: Int, z: Int) -> Coord // Must have a method that allows you get an offset of the coord
    mut def shift(x: Int, y: Int, z: Int) -> Void // Must have a method that shifts the given coord by the given vals
}

/**************************
Impl Statements
**************************/

// Extend the Point method, add some methods
impl Point {
    def toString() -> String = "${x},${y},${z}"
}

// Implement the Coords trait for the Point struct
impl Coords for Point {
    def offs(x a: Int, y b: Int, z c: Int) = Point(x: x + a, y: y + b, z: z + c)
}

/**************************
Generics
**************************/
def add[T](_x: T, _y: T) -> Int = x + y

struct Array[T] { /* Impl */ }

add[Float](1.0, 2.1)
add(1.0, 2.1) // Type inferred

def floatMap(list: Array[Float], cb: (Float) -> Float)) -> Array[Float] = {
    list.map(cb)
}

/**************************
Lambdas
**************************/
// Example method that takes a closure
def sort(list: Array[Int], cb: (item1: Int, item2: Int) -> Bool) = { /* Impl */ }

let exList = Array(1, 2, 3)

sort(list: exList, cb: (item1, item2) => item1 > item2)
sort(list: exList, cb: { (item1, item2) => item1 > item2 })
sort(list: exList, cb: { item1, item2 => item1 > item2 })
sort(list: exList, cb: >)
sort(list: exList) { item1, item2 => item1 > item2 } // Trailing syntax (Same as swifts trailing closure syntax)

/**************************
Refrencing
**************************/
let x = &a // Static reference to a
let y = &mut b // Mutable reference to b

/**************************
Enum
**************************/

enum Test {
    h, i, be()
}
```